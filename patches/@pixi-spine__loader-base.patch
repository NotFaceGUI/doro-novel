diff --git a/lib/atlasLoader.js b/lib/atlasLoader.js
index 1db8a22956ed8870f4ce075670155c8d4bec5206..2488ad7aa2f0f5f2b9ac672aea1e2d7abeabcab1 100644
--- a/lib/atlasLoader.js
+++ b/lib/atlasLoader.js
@@ -31,6 +31,7 @@ const spineTextureAtlasLoader = {
     async parse(asset, options, loader) {
       const metadata = options.data;
       let basePath = core.utils.path.dirname(options.src);
+      console.error("Parsed basePath:", basePath, options.src);
       if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
         basePath += "/";
       }
@@ -61,7 +62,7 @@ const spineTextureAtlasLoader = {
           resolveCallback
         );
       } else {
-        retval = new base.TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);
+        retval = new base.TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, options.src, metadata.imageMetadata), resolveCallback);
       }
       return await retPromise;
     },
@@ -72,16 +73,13 @@ const spineTextureAtlasLoader = {
 };
 const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata) => {
   return async (pageName, textureLoadedCallback) => {
-    try {
-      const url = core.utils.path.normalize([...atlasBasePath.split(core.utils.path.sep), pageName].join(core.utils.path.sep));
-      const texture = await loader.load({ src: url, data: imageMetadata });
-      textureLoadedCallback(texture.baseTexture);
-    } catch (e) {
-      if (base.settings.REPORT_TEXTURE_LOADER_ERROR) {
-        console.error("Spine: error in texture loader", e);
-      }
-      textureLoadedCallback(null);
-    }
+    console.error("loader:", atlasBasePath, imageMetadata);
+    const decodedUrl = decodeURIComponent(atlasBasePath);
+    const decode = decodedUrl.slice(0, decodedUrl.lastIndexOf("\\"));
+    const url = `${decode}/${pageName}`;
+    console.log("\u62FC\u63A5\uFF1A", url);
+    const texture = await loader.load({ src: url, data: imageMetadata });
+    textureLoadedCallback(texture.baseTexture);
   };
 };
 core.extensions.add(spineTextureAtlasLoader);
diff --git a/lib/atlasLoader.js.map b/lib/atlasLoader.js.map
index a645926cb1ec67c26d946f6b5f70fa395a370162..a152e1b1a40867b6a402ab80ef1e51d74eccd025 100644
--- a/lib/atlasLoader.js.map
+++ b/lib/atlasLoader.js.map
@@ -1 +1 @@
-{"version":3,"file":"atlasLoader.js","sources":["../src/atlasLoader.ts"],"sourcesContent":["import { TextureAtlas, settings as spine_settings } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        try {\n            // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n\n            const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n            const texture = await loader.load<Texture>({ src: url, data: imageMetadata });\n\n            textureLoadedCallback(texture.baseTexture);\n        } catch (e) {\n            if (spine_settings.REPORT_TEXTURE_LOADER_ERROR) {\n                console.error('Spine: error in texture loader', e);\n            }\n            textureLoadedCallback(null);\n        }\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n"],"names":["ExtensionType","LoaderParserPriority","checkExtension","settings","utils","TextureAtlas","spine_settings","extensions"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"atlasLoader.js","sources":["../src/atlasLoader.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n            console.error(\"Parsed basePath:\", basePath, options.src); // 调试路径是否正确\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, options.src, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n        console.error(\"loader:\", atlasBasePath, imageMetadata);\n\n        // const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n        const decodedUrl = decodeURIComponent(atlasBasePath);\n        const decode = decodedUrl.slice(0, decodedUrl.lastIndexOf(\"\\\\\")); // 移除最后一个 `/` 后的部分（文件名）\n\n        // 拼接新的路径\n        const url = `${decode}/${pageName}`;\n\n        console.log(\"拼接：\", url);\n\n        const texture = await loader.load<Texture>({ src: url, data: imageMetadata });\n\n        textureLoadedCallback(texture.baseTexture);\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n"],"names":["ExtensionType","LoaderParserPriority","checkExtension","settings","utils","TextureAtlas","extensions"],"mappings":"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"}
\ No newline at end of file
diff --git a/lib/atlasLoader.mjs b/lib/atlasLoader.mjs
index 87a80899e8d011585f642a48484ed911b0971158..d875802cdf6b92a214e423000e452f47e25000f7 100644
--- a/lib/atlasLoader.mjs
+++ b/lib/atlasLoader.mjs
@@ -1,4 +1,4 @@
-import { TextureAtlas, settings as settings$1 } from '@pixi-spine/base';
+import { TextureAtlas } from '@pixi-spine/base';
 import { LoaderParserPriority, checkExtension } from '@pixi/assets';
 import { ExtensionType, settings, utils, extensions } from '@pixi/core';
 
@@ -29,6 +29,7 @@ const spineTextureAtlasLoader = {
     async parse(asset, options, loader) {
       const metadata = options.data;
       let basePath = utils.path.dirname(options.src);
+      console.error("Parsed basePath:", basePath, options.src);
       if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
         basePath += "/";
       }
@@ -59,7 +60,7 @@ const spineTextureAtlasLoader = {
           resolveCallback
         );
       } else {
-        retval = new TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);
+        retval = new TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, options.src, metadata.imageMetadata), resolveCallback);
       }
       return await retPromise;
     },
@@ -70,16 +71,13 @@ const spineTextureAtlasLoader = {
 };
 const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata) => {
   return async (pageName, textureLoadedCallback) => {
-    try {
-      const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));
-      const texture = await loader.load({ src: url, data: imageMetadata });
-      textureLoadedCallback(texture.baseTexture);
-    } catch (e) {
-      if (settings$1.REPORT_TEXTURE_LOADER_ERROR) {
-        console.error("Spine: error in texture loader", e);
-      }
-      textureLoadedCallback(null);
-    }
+    console.error("loader:", atlasBasePath, imageMetadata);
+    const decodedUrl = decodeURIComponent(atlasBasePath);
+    const decode = decodedUrl.slice(0, decodedUrl.lastIndexOf("\\"));
+    const url = `${decode}/${pageName}`;
+    console.log("\u62FC\u63A5\uFF1A", url);
+    const texture = await loader.load({ src: url, data: imageMetadata });
+    textureLoadedCallback(texture.baseTexture);
   };
 };
 extensions.add(spineTextureAtlasLoader);
diff --git a/lib/atlasLoader.mjs.map b/lib/atlasLoader.mjs.map
index 055dba6d5cf84711c97a3513412fc238ec78bcd1..5c5895b6e27c65b75a181100853e33243ef3cc7c 100644
--- a/lib/atlasLoader.mjs.map
+++ b/lib/atlasLoader.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"atlasLoader.mjs","sources":["../src/atlasLoader.ts"],"sourcesContent":["import { TextureAtlas, settings as spine_settings } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        try {\n            // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n\n            const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n            const texture = await loader.load<Texture>({ src: url, data: imageMetadata });\n\n            textureLoadedCallback(texture.baseTexture);\n        } catch (e) {\n            if (spine_settings.REPORT_TEXTURE_LOADER_ERROR) {\n                console.error('Spine: error in texture loader', e);\n            }\n            textureLoadedCallback(null);\n        }\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n"],"names":["spine_settings"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"atlasLoader.mjs","sources":["../src/atlasLoader.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n            console.error(\"Parsed basePath:\", basePath, options.src); // 调试路径是否正确\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, options.src, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n        console.error(\"loader:\", atlasBasePath, imageMetadata);\n\n        // const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n        const decodedUrl = decodeURIComponent(atlasBasePath);\n        const decode = decodedUrl.slice(0, decodedUrl.lastIndexOf(\"\\\\\")); // 移除最后一个 `/` 后的部分（文件名）\n\n        // 拼接新的路径\n        const url = `${decode}/${pageName}`;\n\n        console.log(\"拼接：\", url);\n\n        const texture = await loader.load<Texture>({ src: url, data: imageMetadata });\n\n        textureLoadedCallback(texture.baseTexture);\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n"],"names":[],"mappings":"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"}
